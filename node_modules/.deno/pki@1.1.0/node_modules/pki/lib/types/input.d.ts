import { Input } from '@pulumi/pulumi';
import * as k8s from '@pulumi/kubernetes';
export declare namespace authentication {
    namespace v1alpha1 {
        type StringMatch = Input<{
            exact: Input<string>;
        } | {
            prefix: Input<string>;
        } | {
            suffix: Input<string>;
        } | {
            regex: Input<string>;
        }>;
        interface MutualTls {
            allowTls?: Input<boolean>;
            mode?: Input<Mode>;
        }
        type Mode = Input<'STRICT' | 'PERMISSIVE'>;
        interface Jwt {
            issuer?: Input<string>;
            audiences?: Input<Input<string>[]>;
            jwksUri?: Input<string>;
            jwks?: Input<string>;
            jwtHeaders?: Input<Input<string>[]>;
            jwtParams?: Input<Input<string>[]>;
            triggerRules?: Input<Input<TriggerRule>[]>;
        }
        interface TriggerRule {
            excludedPaths?: Input<Input<StringMatch>[]>;
            includedPaths?: Input<Input<StringMatch>[]>;
        }
        type PeerAuthenticationMethod = Input<{
            mtls: Input<MutualTls>;
        } | {
            jwt: Input<Jwt>;
        }>;
        interface OriginAuthenticationMethod {
            jwt?: Input<Jwt>;
        }
        type PrincipalBinding = Input<'USE_PEER' | 'USE_ORIGIN'>;
        interface PolicyArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Policy>;
        }
        interface Policy {
            targets?: Input<Input<TargetSelector>[]>;
            peers?: Input<Input<PeerAuthenticationMethod>[]>;
            peerIsOptional?: Input<boolean>;
            origins?: Input<Input<OriginAuthenticationMethod>[]>;
            originIsOptional?: Input<boolean>;
            principalBinding?: Input<PrincipalBinding>;
        }
        interface TargetSelector {
            name: Input<string>;
            labels: Input<Record<Input<string>, Input<string>>>;
            ports?: Input<Input<PortSelector>[]>;
        }
        type PortSelector = Input<{
            number: Input<number>;
        } | {
            name: Input<string>;
        }>;
    }
}
export declare namespace mcp {
    namespace v1alpha1 {
        interface SinkNode {
            id?: Input<string>;
            annotations: Input<Record<Input<string>, Input<string>>>;
        }
        interface MeshConfigRequest {
            typeUrl?: Input<string>;
            versionInfo?: Input<string>;
            sinkNode?: Input<SinkNode>;
            responseNonce?: Input<string>;
            errorDetail?: Input<Status>;
        }
        interface MeshConfigResponse {
            typeUrl?: Input<string>;
            versionInfo?: Input<string>;
            nonce?: Input<string>;
        }
        interface IncrementalMeshConfigRequest {
            typeUrl?: Input<string>;
            sinkNode?: Input<SinkNode>;
            responseNonce?: Input<string>;
            errorDetail?: Input<Status>;
            initialResourceVersions: Input<Record<Input<string>, Input<string>>>;
        }
        interface IncrementalMeshConfigResponse {
            nonce?: Input<string>;
            systemVersionInfo?: Input<string>;
            removedResources?: Input<Input<string>[]>;
        }
        interface RequestResources {
            sinkNode?: Input<SinkNode>;
            responseNonce?: Input<string>;
            errorDetail?: Input<Status>;
            initialResourceVersions: Input<Record<Input<string>, Input<string>>>;
            collection?: Input<string>;
            incremental?: Input<boolean>;
        }
        interface Resources {
            nonce: Input<string>;
            systemVersionInfo?: Input<string>;
            removedResources?: Input<Input<string>[]>;
            collection?: Input<string>;
            incremental?: Input<boolean>;
        }
        interface Metadata {
            name?: Input<string>;
            annotations: Input<Record<Input<string>, Input<string>>>;
            createTime?: Input<Timestamp>;
            version?: Input<string>;
            labels: Input<Record<Input<string>, Input<string>>>;
        }
        interface Resource {
            body?: Input<Any>;
            metadata?: Input<Metadata>;
        }
        interface Any {
            typeUrl?: Input<string>;
            value?: Input<string>;
        }
        interface Timestamp {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface Status {
            code?: Input<number>;
            message?: Input<string>;
            details?: Input<Input<Any>[]>;
        }
    }
}
export declare namespace mesh {
    namespace v1alpha1 {
        interface MeshConfig {
            connectTimeout?: Input<Duration>;
            tcpKeepalive?: Input<TcpKeepalive>;
            h2UpgradePolicy?: Input<H2UpgradePolicy>;
            outboundTrafficPolicy?: Input<OutboundTrafficPolicy>;
            mixerCheckServer?: Input<string>;
            mixerReportServer?: Input<string>;
            disablePolicyChecks?: Input<boolean>;
            policyCheckFailOpen?: Input<boolean>;
            sidecarToTelemetrySessionAffinity?: Input<boolean>;
            proxyListenPort?: Input<number>;
            proxyHttpPort?: Input<number>;
            protocolDetectionTimeout?: Input<Duration>;
            ingressClass?: Input<string>;
            ingressService?: Input<string>;
            ingressControllerMode?: Input<IngressControllerMode>;
            authPolicy?: Input<AuthPolicy>;
            rdsRefreshDelay?: Input<Duration>;
            enableTracing?: Input<boolean>;
            accessLogFile?: Input<string>;
            accessLogFormat?: Input<string>;
            accessLogEncoding?: Input<AccessLogEncoding>;
            enableEnvoyAccessLogService?: Input<boolean>;
            defaultConfig?: Input<ProxyConfig>;
            mixerAddress?: Input<string>;
            enableClientSidePolicyCheck?: Input<boolean>;
            sdsUdsPath?: Input<string>;
            sdsRefreshDelay?: Input<Duration>;
            configSources?: Input<Input<ConfigSource>[]>;
            enableSdsTokenMount?: Input<boolean>;
            sdsUseK8sSaJwt?: Input<boolean>;
            trustDomain?: Input<string>;
            defaultServiceExportTo?: Input<Input<string>[]>;
            defaultVirtualServiceExportTo?: Input<Input<string>[]>;
            defaultDestinationRuleExportTo?: Input<Input<string>[]>;
            rootNamespace?: Input<string>;
            localityLbSetting?: Input<LocalityLoadBalancerSetting>;
            dnsRefreshRate?: Input<Duration>;
            disableReportBatch?: Input<boolean>;
            reportBatchMaxEntries?: Input<number>;
            reportBatchMaxTime?: Input<Duration>;
        }
        type IngressControllerMode = Input<'OFF' | 'DEFAULT' | 'STRICT'>;
        type AuthPolicy = Input<'NONE' | 'MUTUAL_TLS'>;
        type AccessLogEncoding = Input<'TEXT' | 'JSON'>;
        interface ProxyConfig {
            connectTimeout?: Input<Duration>;
            configPath?: Input<string>;
            binaryPath?: Input<string>;
            serviceCluster?: Input<string>;
            drainDuration?: Input<Duration>;
            parentShutdownDuration?: Input<Duration>;
            discoveryAddress?: Input<string>;
            discoveryRefreshDelay?: Input<Duration>;
            zipkinAddress?: Input<string>;
            statsdUdpAddress?: Input<string>;
            envoyMetricsServiceAddress?: Input<string>;
            proxyAdminPort?: Input<number>;
            availabilityZone?: Input<string>;
            controlPlaneAuthPolicy?: Input<AuthenticationPolicy>;
            customConfigFile?: Input<string>;
            statNameLength?: Input<number>;
            concurrency?: Input<number>;
            proxyBootstrapTemplatePath?: Input<string>;
            interceptionMode?: Input<InboundInterceptionMode>;
            tracing?: Input<Tracing>;
            sds?: Input<SDS>;
            envoyAccessLogService?: Input<RemoteService>;
            envoyMetricsService?: Input<RemoteService>;
        }
        interface OutboundTrafficPolicy {
            mode?: Input<Mode>;
        }
        interface ConfigSource {
            address?: Input<string>;
            tlsSettings?: Input<TLSSettings>;
        }
        interface LocalityLoadBalancerSetting {
            distribute?: Input<Input<Distribute>[]>;
            failover?: Input<Input<Failover>[]>;
        }
        type H2UpgradePolicy = Input<'DO_NOT_UPGRADE' | 'UPGRADE'>;
        type Mode = Input<'REGISTRY_ONLY' | 'ALLOW_ANY'>;
        interface Distribute {
            from?: Input<string>;
            to: Input<Record<Input<string>, Input<number>>>;
        }
        interface Failover {
            from?: Input<string>;
            to?: Input<string>;
        }
        interface Network {
            endpoints: Input<Input<NetworkEndpoints>[]>;
            gateways: Input<Input<IstioNetworkGateway>[]>;
        }
        type NetworkEndpoints = Input<{
            fromCidr: Input<string>;
        } | {
            fromRegistry: Input<string>;
        }>;
        type IstioNetworkGateway = Input<{
            port: Input<number>;
        } | {
            locality: Input<string>;
        } | {
            registryServiceName: Input<string>;
        } | {
            port: Input<number>;
        } | {
            address: Input<string>;
        } | {
            locality: Input<string>;
        }>;
        interface MeshNetworks {
            networks: Input<Record<Input<string>, Input<Network>>>;
        }
        type AuthenticationPolicy = Input<'NONE' | 'MUTUAL_TLS' | 'INHERIT'>;
        type Tracing = Input<{
            zipkin: Input<Zipkin>;
        } | {
            lightstep: Input<Lightstep>;
        } | {
            datadog: Input<Datadog>;
        } | {
            stackdriver: Input<Stackdriver>;
        }>;
        interface Zipkin {
            address?: Input<string>;
        }
        interface Lightstep {
            address?: Input<string>;
            accessToken?: Input<string>;
            secure?: Input<boolean>;
            cacertPath?: Input<string>;
        }
        interface Datadog {
            address?: Input<string>;
        }
        interface Stackdriver {
            debug?: Input<boolean>;
            maxNumberOfAttributes?: Input<Int64Value>;
            maxNumberOfAnnotations?: Input<Int64Value>;
            maxNumberOfMessageEvents?: Input<Int64Value>;
        }
        interface SDS {
            enabled?: Input<boolean>;
            k8sSaJwtPath?: Input<string>;
        }
        type InboundInterceptionMode = Input<'REDIRECT' | 'TPROXY'>;
        interface RemoteService {
            tcpKeepalive?: Input<TcpKeepalive>;
            address?: Input<string>;
            tlsSettings?: Input<TLSSettings>;
        }
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface Int64Value {
            value?: Input<number>;
        }
        interface TcpKeepalive {
            time?: Input<Duration>;
            probes?: Input<number>;
            interval?: Input<Duration>;
        }
        interface TLSSettings {
            mode?: Input<TLSmode>;
            clientCertificate: Input<string>;
            privateKey: Input<string>;
            caCertificates?: Input<string>;
            subjectAltNames?: Input<Input<string>[]>;
            sni?: Input<string>;
        }
        type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
    }
}
export declare namespace mixer {
    namespace v1 {
        interface Attributes {
            attributes: Input<Record<Input<string>, Input<AttributeValue>>>;
        }
        type AttributeValue = Input<{
            stringValue: Input<string>;
        } | {
            int64Value: Input<number>;
        } | {
            doubleValue: Input<number>;
        } | {
            boolValue: Input<boolean>;
        } | {
            bytesValue: Input<string>;
        } | {
            timestampValue: Input<Timestamp>;
        } | {
            durationValue: Input<Duration>;
        } | {
            stringMapValue: Input<StringMap>;
        }>;
        interface StringMap {
            entries: Input<Record<Input<string>, Input<string>>>;
        }
        interface CompressedAttributes {
            strings: Input<Record<Input<string>, Input<number>>>;
            bytes: Input<object>;
            words?: Input<Input<string>[]>;
            int64s: Input<Record<Input<string>, Input<number>>>;
            doubles: Input<Record<Input<string>, Input<number>>>;
            bools: Input<Record<Input<string>, Input<boolean>>>;
            timestamps: Input<Record<Input<string>, Input<Timestamp>>>;
            durations: Input<Record<Input<string>, Input<Duration>>>;
            stringMaps: Input<Record<Input<string>, Input<StringMap>>>;
        }
        interface StringMap {
            entries: Input<Record<Input<string>, Input<number>>>;
        }
        interface CheckRequest {
            globalWordCount?: Input<number>;
            deduplicationId?: Input<string>;
            quotas: Input<Record<Input<string>, Input<QuotaParams>>>;
        }
        interface QuotaParams {
            amount?: Input<number>;
            bestEffort?: Input<boolean>;
        }
        interface CheckResponse {
            quotas: Input<Record<Input<string>, Input<QuotaResult>>>;
        }
        interface QuotaResult {
            grantedAmount?: Input<number>;
        }
        interface PreconditionResult {
            validUseCount?: Input<number>;
            referencedAttributes?: Input<ReferencedAttributes>;
            routeDirective?: Input<RouteDirective>;
        }
        interface ReferencedAttributes {
            words?: Input<Input<string>[]>;
        }
        interface RouteDirective {
            directResponseCode?: Input<number>;
            directResponseBody?: Input<string>;
        }
        type Condition = Input<'CONDITION_UNSPECIFIED' | 'ABSENCE' | 'EXACT' | 'REGEX'>;
        interface AttributeMatch {
            name?: Input<number>;
            condition?: Input<Condition>;
            regex?: Input<string>;
            mapKey?: Input<number>;
        }
        interface HeaderOperation {
            name?: Input<string>;
            value?: Input<string>;
            operation?: Input<Operation>;
        }
        type Operation = Input<'REPLACE' | 'REMOVE' | 'APPEND'>;
        interface ReportRequest {
            globalWordCount?: Input<number>;
            repeatedAttributesSemantics?: Input<RepeatedAttributesSemantics>;
            defaultWords?: Input<Input<string>[]>;
        }
        type RepeatedAttributesSemantics = Input<'DELTA_ENCODING' | 'INDEPENDENT_ENCODING'>;
        interface ReportResponse {
        }
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface Timestamp {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface HTTPAPISpecArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<HTTPAPISpec>;
        }
        interface HTTPAPISpec {
            attributes?: Input<Attributes>;
            patterns?: Input<Input<HTTPAPISpecPattern>[]>;
            apiKeys?: Input<Input<APIKey>[]>;
        }
        type HTTPAPISpecPattern = Input<{
            attributes: Input<Attributes>;
        } | {
            httpMethod: Input<string>;
        } | {
            uriTemplate: Input<string>;
        } | {
            attributes: Input<Attributes>;
        } | {
            regex: Input<string>;
        } | {
            httpMethod: Input<string>;
        }>;
        type APIKey = Input<{
            query: Input<string>;
        } | {
            header: Input<string>;
        } | {
            cookie: Input<string>;
        }>;
        interface HTTPAPISpecReference {
            name: Input<string>;
            namespace?: Input<string>;
        }
        interface HTTPAPISpecBindingArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<HTTPAPISpecBinding>;
        }
        interface HTTPAPISpecBinding {
            services: Input<Input<IstioService>[]>;
            apiSpecs: Input<Input<HTTPAPISpecReference>[]>;
        }
        interface IstioService {
            name?: Input<string>;
            namespace?: Input<string>;
            domain?: Input<string>;
            service?: Input<string>;
            labels: Input<Record<Input<string>, Input<string>>>;
        }
        interface NetworkFailPolicy {
            policy?: Input<FailPolicy>;
            maxRetry?: Input<number>;
            baseRetryWait?: Input<Duration>;
            maxRetryWait?: Input<Duration>;
        }
        type FailPolicy = Input<'FAIL_OPEN' | 'FAIL_CLOSE'>;
        interface ServiceConfig {
            disableCheckCalls?: Input<boolean>;
            disableReportCalls?: Input<boolean>;
            mixerAttributes?: Input<Attributes>;
            httpApiSpec?: Input<Input<HTTPAPISpec>[]>;
            quotaSpec?: Input<Input<QuotaSpec>[]>;
            networkFailPolicy?: Input<NetworkFailPolicy>;
            forwardAttributes?: Input<Attributes>;
        }
        interface QuotaSpec {
            rules?: Input<Input<QuotaRule>[]>;
        }
        interface TransportConfig {
            networkFailPolicy?: Input<NetworkFailPolicy>;
            disableCheckCache?: Input<boolean>;
            disableQuotaCache?: Input<boolean>;
            disableReportBatch?: Input<boolean>;
            statsUpdateInterval?: Input<Duration>;
            checkCluster?: Input<string>;
            reportCluster?: Input<string>;
            attributesForMixerProxy?: Input<Attributes>;
            reportBatchMaxEntries?: Input<number>;
            reportBatchMaxTime?: Input<Duration>;
        }
        interface HttpClientConfig {
            mixerAttributes?: Input<Attributes>;
            forwardAttributes?: Input<Attributes>;
            transport?: Input<TransportConfig>;
            serviceConfigs: Input<Record<Input<string>, Input<ServiceConfig>>>;
            defaultDestinationService?: Input<string>;
        }
        interface TcpClientConfig {
            disableCheckCalls?: Input<boolean>;
            disableReportCalls?: Input<boolean>;
            mixerAttributes?: Input<Attributes>;
            transport?: Input<TransportConfig>;
            connectionQuotaSpec?: Input<QuotaSpec>;
            reportInterval?: Input<Duration>;
        }
        interface QuotaRule {
            quotas?: Input<Input<Quota>[]>;
            match?: Input<Input<AttributeMatch>[]>;
        }
        interface AttributeMatch {
            clause: Input<Record<Input<string>, Input<StringMatch>>>;
        }
        interface Quota {
            quota?: Input<string>;
            charge?: Input<number>;
        }
        type StringMatch = Input<{
            exact: Input<string>;
        } | {
            prefix: Input<string>;
        } | {
            regex: Input<string>;
        }>;
        interface QuotaSpecBinding {
            services: Input<Input<IstioService>[]>;
            quotaSpecs: Input<Input<QuotaSpecReference>[]>;
        }
        interface QuotaSpecReference {
            name: Input<string>;
            namespace?: Input<string>;
        }
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface Attributes {
            attributes: Input<Record<Input<string>, Input<AttributeValue>>>;
        }
        type AttributeValue = Input<{
            stringValue: Input<string>;
        } | {
            int64Value: Input<number>;
        } | {
            doubleValue: Input<number>;
        } | {
            boolValue: Input<boolean>;
        } | {
            bytesValue: Input<string>;
        } | {
            timestampValue: Input<Timestamp>;
        } | {
            durationValue: Input<Duration>;
        } | {
            stringMapValue: Input<StringMap>;
        }>;
        interface Timestamp {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface StringMap {
            entries: Input<Record<Input<string>, Input<string>>>;
        }
    }
}
export declare namespace networking {
    namespace v1alpha3 {
        interface DestinationRuleArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<DestinationRule>;
        }
        interface DestinationRule {
            host: Input<string>;
            trafficPolicy?: Input<TrafficPolicy>;
            subsets?: Input<Input<Subset>[]>;
            exportTo?: Input<Input<string>[]>;
        }
        interface TrafficPolicy {
            loadBalancer?: Input<LoadBalancerSettings>;
            connectionPool?: Input<ConnectionPoolSettings>;
            outlierDetection?: Input<OutlierDetection>;
            tls?: Input<TLSSettings>;
            portLevelSettings?: Input<Input<PortTrafficPolicy>[]>;
        }
        interface Subset {
            name: Input<string>;
            trafficPolicy?: Input<TrafficPolicy>;
            labels: Input<Record<Input<string>, Input<string>>>;
        }
        type LoadBalancerSettings = Input<{
            simple: Input<SimpleLB>;
        } | {
            consistentHash: Input<ConsistentHashLB>;
        }>;
        interface ConnectionPoolSettings {
            tcp?: Input<TCPSettings>;
            http?: Input<HTTPSettings>;
        }
        interface OutlierDetection {
            interval?: Input<Duration>;
            consecutiveErrors?: Input<number>;
            baseEjectionTime?: Input<Duration>;
            maxEjectionPercent?: Input<number>;
            minHealthPercent?: Input<number>;
        }
        interface TLSSettings {
            mode?: Input<TLSmode>;
            clientCertificate: Input<string>;
            privateKey: Input<string>;
            caCertificates?: Input<string>;
            subjectAltNames?: Input<Input<string>[]>;
            sni?: Input<string>;
        }
        interface PortTrafficPolicy {
            loadBalancer?: Input<LoadBalancerSettings>;
            connectionPool?: Input<ConnectionPoolSettings>;
            outlierDetection?: Input<OutlierDetection>;
            tls?: Input<TLSSettings>;
            port?: Input<PortSelector>;
        }
        type PortSelector = Input<{
            number: Input<number>;
        } | {
            name: Input<string>;
        }>;
        type SimpleLB = Input<'ROUND_ROBIN' | 'LEAST_CONN' | 'RANDOM' | 'PASSTHROUGH'>;
        type ConsistentHashLB = Input<{
            minimumRingSize: Input<number>;
        } | {
            httpHeaderName: Input<string>;
        } | {
            minimumRingSize: Input<number>;
        } | {
            httpCookie: Input<HTTPCookie>;
        } | {
            minimumRingSize: Input<number>;
        } | {
            useSourceIp: Input<boolean>;
        }>;
        interface HTTPCookie {
            path?: Input<string>;
            name: Input<string>;
        }
        interface TCPSettings {
            maxConnections?: Input<number>;
            connectTimeout?: Input<Duration>;
            tcpKeepalive?: Input<TcpKeepalive>;
        }
        interface HTTPSettings {
            http1MaxPendingRequests?: Input<number>;
            http2MaxRequests?: Input<number>;
            maxRequestsPerConnection?: Input<number>;
            maxRetries?: Input<number>;
            idleTimeout?: Input<Duration>;
            h2UpgradePolicy?: Input<H2UpgradePolicy>;
        }
        interface TcpKeepalive {
            time?: Input<Duration>;
            probes?: Input<number>;
            interval?: Input<Duration>;
        }
        type H2UpgradePolicy = Input<'DEFAULT' | 'DO_NOT_UPGRADE' | 'UPGRADE'>;
        type TLSmode = Input<'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL'>;
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface EnvoyFilterArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<EnvoyFilter>;
        }
        interface EnvoyFilter {
            workloadLabels: Input<Record<Input<string>, Input<string>>>;
            filters?: Input<Input<Filter>[]>;
            workloadSelector?: Input<WorkloadSelector>;
            configPatches: Input<Input<EnvoyConfigObjectPatch>[]>;
        }
        interface Filter {
            listenerMatch?: Input<DeprecatedListenerMatch>;
            insertPosition?: Input<InsertPosition>;
            filterType?: Input<FilterType>;
            filterName: Input<string>;
            filterConfig?: Input<Struct>;
        }
        interface WorkloadSelector {
            labels: Input<Record<Input<string>, Input<string>>>;
        }
        interface EnvoyConfigObjectPatch {
            applyTo?: Input<ApplyTo>;
            match?: Input<EnvoyConfigObjectMatch>;
            patch?: Input<Patch>;
        }
        interface DeprecatedListenerMatch {
            portNumber?: Input<number>;
            portNamePrefix?: Input<string>;
            listenerType?: Input<ListenerType>;
            listenerProtocol?: Input<ListenerProtocol>;
            address?: Input<Input<string>[]>;
        }
        type ListenerType = Input<'ANY' | 'SIDECAR_INBOUND' | 'SIDECAR_OUTBOUND' | 'GATEWAY'>;
        type ListenerProtocol = Input<'ALL' | 'HTTP' | 'TCP'>;
        interface InsertPosition {
            index?: Input<Index>;
            relativeTo?: Input<string>;
        }
        type Index = Input<'FIRST' | 'LAST' | 'BEFORE' | 'AFTER'>;
        type FilterType = Input<'INVALID' | 'HTTP' | 'NETWORK'>;
        type ApplyTo = Input<'INVALID' | 'LISTENER' | 'FILTER_CHAIN' | 'NETWORK_FILTER' | 'HTTP_FILTER' | 'ROUTE_CONFIGURATION' | 'VIRTUAL_HOST' | 'HTTP_ROUTE' | 'CLUSTER'>;
        type PatchContext = Input<'ANY' | 'SIDECAR_INBOUND' | 'SIDECAR_OUTBOUND' | 'GATEWAY'>;
        interface ProxyMatch {
            proxyVersion?: Input<string>;
            metadata: Input<Record<Input<string>, Input<string>>>;
        }
        interface ClusterMatch {
            name?: Input<string>;
            portNumber?: Input<number>;
            service?: Input<string>;
            subset?: Input<string>;
        }
        interface RouteConfigurationMatch {
            name?: Input<string>;
            portNumber?: Input<number>;
            portName?: Input<string>;
            gateway?: Input<string>;
            vhost?: Input<VirtualHostMatch>;
        }
        interface VirtualHostMatch {
            name?: Input<string>;
            route?: Input<RouteMatch>;
        }
        interface RouteMatch {
            name?: Input<string>;
            action?: Input<Action>;
        }
        type Action = Input<'ANY' | 'ROUTE' | 'REDIRECT' | 'DIRECT_RESPONSE'>;
        interface ListenerMatch {
            name?: Input<string>;
            portNumber?: Input<number>;
            portName?: Input<string>;
            filterChain?: Input<FilterChainMatch>;
        }
        interface FilterChainMatch {
            name?: Input<string>;
            sni?: Input<string>;
            transportProtocol?: Input<string>;
            applicationProtocols?: Input<string>;
            filter?: Input<FilterMatch>;
        }
        interface FilterMatch {
            name?: Input<string>;
            subFilter?: Input<SubFilterMatch>;
        }
        interface SubFilterMatch {
            name?: Input<string>;
        }
        interface Patch {
            operation?: Input<Operation>;
            value?: Input<Struct>;
        }
        type Operation = Input<'INVALID' | 'MERGE' | 'ADD' | 'REMOVE' | 'INSERT_BEFORE' | 'INSERT_AFTER'>;
        type EnvoyConfigObjectMatch = Input<{
            context: Input<PatchContext>;
        } | {
            proxy: Input<ProxyMatch>;
        } | {
            listener: Input<ListenerMatch>;
        } | {
            context: Input<PatchContext>;
        } | {
            proxy: Input<ProxyMatch>;
        } | {
            routeConfiguration: Input<RouteConfigurationMatch>;
        } | {
            context: Input<PatchContext>;
        } | {
            proxy: Input<ProxyMatch>;
        } | {
            cluster: Input<ClusterMatch>;
        }>;
        interface Struct {
            fields: Input<Record<Input<string>, Input<Value>>>;
        }
        type Value = Input<{
            nullValue: Input<NullValue>;
        } | {
            numberValue: Input<number>;
        } | {
            stringValue: Input<string>;
        } | {
            boolValue: Input<boolean>;
        } | {
            structValue: Input<Struct>;
        } | {
            listValue: Input<ListValue>;
        }>;
        interface ListValue {
            values?: Input<Input<Value>[]>;
        }
        type NullValue = Input<'NULL_VALUE'>;
        interface GatewayArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Gateway>;
        }
        interface Gateway {
            servers: Input<Input<Server>[]>;
            selector: Input<Record<Input<string>, Input<string>>>;
        }
        interface Server {
            tls?: Input<TLSOptions>;
            port?: Input<Port>;
            bind?: Input<string>;
            hosts: Input<Input<string>[]>;
            defaultEndpoint?: Input<string>;
        }
        interface Port {
            name?: Input<string>;
            number: Input<number>;
            protocol: Input<string>;
        }
        interface TLSOptions {
            mode?: Input<TLSmode>;
            privateKey: Input<string>;
            caCertificates: Input<string>;
            subjectAltNames?: Input<Input<string>[]>;
            httpsRedirect?: Input<boolean>;
            serverCertificate: Input<string>;
            credentialName?: Input<string>;
            verifyCertificateSpki?: Input<Input<string>[]>;
            verifyCertificateHash?: Input<Input<string>[]>;
            minProtocolVersion?: Input<TLSProtocol>;
            maxProtocolVersion?: Input<TLSProtocol>;
            cipherSuites?: Input<Input<string>[]>;
        }
        type TLSmode = Input<'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL'>;
        type TLSProtocol = Input<'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3'>;
        interface Port {
            name?: Input<string>;
            number: Input<number>;
            protocol: Input<string>;
        }
        interface ServiceEntryArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<ServiceEntry>;
        }
        interface ServiceEntry {
            exportTo?: Input<Input<string>[]>;
            subjectAltNames?: Input<Input<string>[]>;
            hosts: Input<Input<string>[]>;
            addresses?: Input<Input<string>[]>;
            ports: Input<Input<Port>[]>;
            location?: Input<Location>;
            resolution?: Input<Resolution>;
            endpoints?: Input<Input<Endpoint>[]>;
        }
        type Location = Input<'MESH_EXTERNAL' | 'MESH_INTERNAL'>;
        type Resolution = Input<'NONE' | 'STATIC' | 'DNS'>;
        interface Endpoint {
            labels: Input<Record<Input<string>, Input<string>>>;
            address: Input<string>;
            ports: Input<Record<Input<string>, Input<number>>>;
            network?: Input<string>;
            locality?: Input<string>;
            weight?: Input<number>;
        }
        interface WorkloadSelector {
            labels: Input<Record<Input<string>, Input<string>>>;
        }
        interface Port {
            name?: Input<string>;
            number: Input<number>;
            protocol: Input<string>;
        }
        interface SidecarArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Sidecar>;
        }
        interface Sidecar {
            workloadSelector?: Input<WorkloadSelector>;
            ingress?: Input<Input<IstioIngressListener>[]>;
            egress: Input<Input<IstioEgressListener>[]>;
            outboundTrafficPolicy?: Input<OutboundTrafficPolicy>;
        }
        interface IstioIngressListener {
            port?: Input<Port>;
            bind?: Input<string>;
            defaultEndpoint: Input<string>;
            captureMode?: Input<CaptureMode>;
        }
        interface IstioEgressListener {
            port?: Input<Port>;
            bind?: Input<string>;
            hosts: Input<Input<string>[]>;
            captureMode?: Input<CaptureMode>;
        }
        interface OutboundTrafficPolicy {
            mode?: Input<Mode>;
        }
        type CaptureMode = Input<'DEFAULT' | 'IPTABLES' | 'NONE'>;
        type Mode = Input<'REGISTRY_ONLY' | 'ALLOW_ANY'>;
        type PortSelector = Input<{
            number: Input<number>;
        } | {
            name: Input<string>;
        }>;
        interface VirtualServiceArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<VirtualService>;
        }
        interface VirtualService {
            exportTo?: Input<Input<string>[]>;
            tls?: Input<Input<TLSRoute>[]>;
            tcp?: Input<Input<TCPRoute>[]>;
            http?: Input<Input<HTTPRoute>[]>;
            hosts: Input<Input<string>[]>;
            gateways?: Input<Input<string>[]>;
        }
        interface HTTPRoute {
            name?: Input<string>;
            route?: Input<Input<HTTPRouteDestination>[]>;
            match?: Input<Input<HTTPMatchRequest>[]>;
            redirect?: Input<HTTPRedirect>;
            rewrite?: Input<HTTPRewrite>;
            websocketUpgrade?: Input<boolean>;
            timeout?: Input<Duration>;
            retries?: Input<HTTPRetry>;
            fault?: Input<HTTPFaultInjection>;
            mirror?: Input<Destination>;
            corsPolicy?: Input<CorsPolicy>;
            appendHeaders: Input<Record<Input<string>, Input<string>>>;
            removeResponseHeaders?: Input<Input<string>[]>;
            appendResponseHeaders: Input<Record<Input<string>, Input<string>>>;
            removeRequestHeaders?: Input<Input<string>[]>;
            appendRequestHeaders: Input<Record<Input<string>, Input<string>>>;
            headers?: Input<Headers>;
        }
        interface TLSRoute {
            route?: Input<Input<RouteDestination>[]>;
            match: Input<Input<TLSMatchAttributes>[]>;
        }
        interface TCPRoute {
            route?: Input<Input<RouteDestination>[]>;
            match?: Input<Input<L4MatchAttributes>[]>;
        }
        interface Destination {
            host: Input<string>;
            port?: Input<PortSelector>;
            subset?: Input<string>;
        }
        interface HTTPMatchRequest {
            name?: Input<string>;
            method?: Input<StringMatch>;
            port?: Input<number>;
            gateways?: Input<Input<string>[]>;
            headers: Input<Record<Input<string>, Input<StringMatch>>>;
            uri?: Input<StringMatch>;
            scheme?: Input<StringMatch>;
            authority?: Input<StringMatch>;
            sourceLabels: Input<Record<Input<string>, Input<string>>>;
            queryParams: Input<Record<Input<string>, Input<StringMatch>>>;
            ignoreUriCase?: Input<boolean>;
        }
        interface HTTPRouteDestination {
            weight: Input<number>;
            removeResponseHeaders?: Input<Input<string>[]>;
            appendResponseHeaders: Input<Record<Input<string>, Input<string>>>;
            removeRequestHeaders?: Input<Input<string>[]>;
            appendRequestHeaders: Input<Record<Input<string>, Input<string>>>;
            headers?: Input<Headers>;
            destination?: Input<Destination>;
        }
        interface HTTPRedirect {
            uri?: Input<string>;
            authority?: Input<string>;
            redirectCode?: Input<number>;
        }
        interface HTTPRewrite {
            uri?: Input<string>;
            authority?: Input<string>;
        }
        interface HTTPRetry {
            attempts: Input<number>;
            perTryTimeout?: Input<Duration>;
            retryOn?: Input<string>;
        }
        interface HTTPFaultInjection {
            delay?: Input<Delay>;
            abort?: Input<Abort>;
        }
        interface CorsPolicy {
            allowOrigin?: Input<Input<string>[]>;
            allowMethods?: Input<Input<string>[]>;
            allowHeaders?: Input<Input<string>[]>;
            exposeHeaders?: Input<Input<string>[]>;
            maxAge?: Input<Duration>;
            allowCredentials?: Input<BoolValue>;
        }
        interface Headers {
            response?: Input<HeaderOperations>;
            request?: Input<HeaderOperations>;
        }
        interface HeaderOperations {
            set: Input<Record<Input<string>, Input<string>>>;
            add: Input<Record<Input<string>, Input<string>>>;
            remove?: Input<Input<string>[]>;
        }
        interface TLSMatchAttributes {
            port?: Input<number>;
            gateways?: Input<Input<string>[]>;
            sourceLabels: Input<Record<Input<string>, Input<string>>>;
            destinationSubnets?: Input<Input<string>[]>;
            sourceSubnet?: Input<string>;
            sniHosts: Input<Input<string>[]>;
        }
        interface RouteDestination {
            weight: Input<number>;
            destination?: Input<Destination>;
        }
        interface L4MatchAttributes {
            port?: Input<number>;
            gateways?: Input<Input<string>[]>;
            sourceLabels: Input<Record<Input<string>, Input<string>>>;
            destinationSubnets?: Input<Input<string>[]>;
            sourceSubnet?: Input<string>;
        }
        type StringMatch = Input<{
            exact: Input<string>;
        } | {
            prefix: Input<string>;
        } | {
            regex: Input<string>;
        }>;
        type Delay = Input<{
            percent: Input<number>;
        } | {
            percentage: Input<Percent>;
        } | {
            fixedDelay: Input<Duration>;
        } | {
            percent: Input<number>;
        } | {
            percentage: Input<Percent>;
        } | {
            exponentialDelay: Input<Duration>;
        }>;
        type Abort = Input<{
            percent: Input<number>;
        } | {
            percentage: Input<Percent>;
        } | {
            httpStatus: Input<number>;
        } | {
            percent: Input<number>;
        } | {
            percentage: Input<Percent>;
        } | {
            grpcStatus: Input<string>;
        } | {
            percent: Input<number>;
        } | {
            percentage: Input<Percent>;
        } | {
            http2Error: Input<string>;
        }>;
        interface Percent {
            value?: Input<number>;
        }
        interface BoolValue {
            value?: Input<boolean>;
        }
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
    }
}
export declare namespace policy {
    namespace v1beta1 {
        interface Duration {
            value?: Input<Duration>;
        }
        type Value = Input<{
            stringValue: Input<string>;
        } | {
            int64Value: Input<number>;
        } | {
            doubleValue: Input<number>;
        } | {
            boolValue: Input<boolean>;
        } | {
            ipAddressValue: Input<IPAddress>;
        } | {
            timestampValue: Input<TimeStamp>;
        } | {
            durationValue: Input<Duration>;
        } | {
            emailAddressValue: Input<EmailAddress>;
        } | {
            dnsNameValue: Input<DNSName>;
        } | {
            uriValue: Input<Uri>;
        } | {
            stringMapValue: Input<StringMap>;
        }>;
        interface AttributeManifest {
            name: Input<string>;
            revision?: Input<string>;
            attributes: Input<Record<Input<string>, Input<AttributeInfo>>>;
        }
        interface AttributeInfo {
            description?: Input<string>;
            valueType?: Input<ValueType>;
        }
        type ValueType = Input<'VALUE_TYPE_UNSPECIFIED' | 'STRING' | 'INT64' | 'DOUBLE' | 'BOOL' | 'TIMESTAMP' | 'IP_ADDRESS' | 'EMAIL_ADDRESS' | 'URI' | 'DNS_NAME' | 'DURATION' | 'STRING_MAP'>;
        interface RuleArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Rule>;
        }
        interface Rule {
            match: Input<string>;
            actions?: Input<Input<Action>[]>;
            requestHeaderOperations?: Input<Input<HeaderOperationTemplate>[]>;
            responseHeaderOperations?: Input<Input<HeaderOperationTemplate>[]>;
            sampling?: Input<Sampling>;
        }
        interface Action {
            name?: Input<string>;
            handler: Input<string>;
            instances: Input<Input<string>[]>;
        }
        interface HeaderOperationTemplate {
            name: Input<string>;
            values?: Input<Input<string>[]>;
            operation?: Input<Operation>;
        }
        interface Sampling {
            random?: Input<RandomSampling>;
            rateLimit?: Input<RateLimitSampling>;
        }
        type Operation = Input<'REPLACE' | 'REMOVE' | 'APPEND'>;
        interface InstanceArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Instance>;
        }
        interface Instance {
            name: Input<string>;
            compiledTemplate: Input<string>;
            template: Input<string>;
            params?: Input<Struct>;
            attributeBindings: Input<Record<Input<string>, Input<string>>>;
        }
        interface HandlerArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Handler>;
        }
        interface Handler {
            name: Input<string>;
            params?: Input<Struct>;
            compiledAdapter: Input<string>;
            adapter: Input<string>;
            connection?: Input<Connection>;
        }
        interface Connection {
            address?: Input<string>;
            authentication?: Input<Authentication>;
        }
        type Authentication = Input<{
            tls: Input<Tls>;
        } | {
            mutual: Input<Mutual>;
        }>;
        interface RandomSampling {
            attributeExpression?: Input<string>;
            percentSampled?: Input<FractionalPercent>;
            useIndependentRandomness?: Input<boolean>;
        }
        interface RateLimitSampling {
            maxUnsampledEntries?: Input<number>;
            samplingRate?: Input<number>;
        }
        interface FractionalPercent {
            numerator?: Input<number>;
            denominator?: Input<DenominatorType>;
        }
        type DenominatorType = Input<'HUNDRED' | 'TEN_THOUSAND'>;
        type Tls = Input<{
            caCertificates: Input<string>;
        } | {
            serverName: Input<string>;
        } | {
            tokenPath: Input<string>;
        } | {
            authHeader: Input<AuthHeader>;
        } | {
            caCertificates: Input<string>;
        } | {
            serverName: Input<string>;
        } | {
            tokenPath: Input<string>;
        } | {
            customHeader: Input<string>;
        } | {
            caCertificates: Input<string>;
        } | {
            serverName: Input<string>;
        } | {
            oauth: Input<OAuth>;
        } | {
            authHeader: Input<AuthHeader>;
        } | {
            caCertificates: Input<string>;
        } | {
            serverName: Input<string>;
        } | {
            oauth: Input<OAuth>;
        } | {
            customHeader: Input<string>;
        }>;
        interface Mutual {
            caCertificates?: Input<string>;
            serverName?: Input<string>;
            privateKey?: Input<string>;
            clientCertificate?: Input<string>;
        }
        interface OAuth {
            clientId: Input<string>;
            clientSecret: Input<string>;
            tokenUrl: Input<string>;
            scopes?: Input<Input<string>[]>;
            endpointParams: Input<Record<Input<string>, Input<string>>>;
        }
        type AuthHeader = Input<'PLAIN' | 'BEARER'>;
        interface DirectHttpResponse {
            body?: Input<string>;
            code?: Input<HttpStatusCode>;
            headers: Input<Record<Input<string>, Input<string>>>;
        }
        type HttpStatusCode = Input<'Empty' | 'Continue' | 'OK' | 'Created' | 'Accepted' | 'NonAuthoritativeInformation' | 'NoContent' | 'ResetContent' | 'PartialContent' | 'MultiStatus' | 'AlreadyReported' | 'IMUsed' | 'MultipleChoices' | 'MovedPermanently' | 'Found' | 'SeeOther' | 'NotModified' | 'UseProxy' | 'TemporaryRedirect' | 'PermanentRedirect' | 'BadRequest' | 'Unauthorized' | 'PaymentRequired' | 'Forbidden' | 'NotFound' | 'MethodNotAllowed' | 'NotAcceptable' | 'ProxyAuthenticationRequired' | 'RequestTimeout' | 'Conflict' | 'Gone' | 'LengthRequired' | 'PreconditionFailed' | 'PayloadTooLarge' | 'URITooLong' | 'UnsupportedMediaType' | 'RangeNotSatisfiable' | 'ExpectationFailed' | 'MisdirectedRequest' | 'UnprocessableEntity' | 'Locked' | 'FailedDependency' | 'UpgradeRequired' | 'PreconditionRequired' | 'TooManyRequests' | 'RequestHeaderFieldsTooLarge' | 'InternalServerError' | 'NotImplemented' | 'BadGateway' | 'ServiceUnavailable' | 'GatewayTimeout' | 'HTTPVersionNotSupported' | 'VariantAlsoNegotiates' | 'InsufficientStorage' | 'LoopDetected' | 'NotExtended' | 'NetworkAuthenticationRequired'>;
        interface IPAddress {
            value?: Input<string>;
        }
        interface TimeStamp {
            value?: Input<Timestamp>;
        }
        interface EmailAddress {
            value?: Input<string>;
        }
        interface DNSName {
            value?: Input<string>;
        }
        interface Uri {
            value?: Input<string>;
        }
        interface StringMap {
            value: Input<Record<Input<string>, Input<string>>>;
        }
        interface Duration {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        interface Struct {
            fields: Input<Record<Input<string>, Input<Value>>>;
        }
        interface Timestamp {
            seconds?: Input<number>;
            nanos?: Input<number>;
        }
        type Value = Input<{
            nullValue: Input<NullValue>;
        } | {
            numberValue: Input<number>;
        } | {
            stringValue: Input<string>;
        } | {
            boolValue: Input<boolean>;
        } | {
            structValue: Input<Struct>;
        } | {
            listValue: Input<ListValue>;
        }>;
        interface ListValue {
            values?: Input<Input<Value>[]>;
        }
        type NullValue = Input<'NULL_VALUE'>;
    }
}
export declare namespace rbac {
    namespace v1alpha1 {
        interface ServiceRoleArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<ServiceRole>;
        }
        interface ServiceRole {
            rules: Input<Input<AccessRule>[]>;
        }
        interface AccessRule {
            services: Input<Input<string>[]>;
            hosts?: Input<Input<string>[]>;
            notHosts?: Input<Input<string>[]>;
            paths?: Input<Input<string>[]>;
            notPaths?: Input<Input<string>[]>;
            methods?: Input<Input<string>[]>;
            notMethods?: Input<Input<string>[]>;
            ports?: Input<Input<number>[]>;
            notPorts?: Input<Input<number>[]>;
            constraints?: Input<Input<Constraint>[]>;
        }
        interface Constraint {
            key?: Input<string>;
            values?: Input<Input<string>[]>;
        }
        type EnforcementMode = Input<'ENFORCED' | 'PERMISSIVE'>;
        interface ServiceRoleBindingArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<ServiceRoleBinding>;
        }
        interface ServiceRoleBinding {
            subjects: Input<Input<Subject>[]>;
            roleRef?: Input<RoleRef>;
            mode?: Input<EnforcementMode>;
            actions?: Input<Input<AccessRule>[]>;
            role?: Input<string>;
        }
        interface Subject {
            user?: Input<string>;
            names?: Input<Input<string>[]>;
            notNames?: Input<Input<string>[]>;
            group?: Input<string>;
            groups?: Input<Input<string>[]>;
            notGroups?: Input<Input<string>[]>;
            namespaces?: Input<Input<string>[]>;
            notNamespaces?: Input<Input<string>[]>;
            ips?: Input<Input<string>[]>;
            notIps?: Input<Input<string>[]>;
            properties: Input<Record<Input<string>, Input<string>>>;
        }
        interface RoleRef {
            name: Input<string>;
            kind: Input<string>;
        }
        interface RbacConfig {
            mode?: Input<Mode>;
            inclusion?: Input<Target>;
            exclusion?: Input<Target>;
            enforcementMode?: Input<EnforcementMode>;
        }
        type Mode = Input<'OFF' | 'ON' | 'ON_WITH_INCLUSION' | 'ON_WITH_EXCLUSION'>;
        interface Target {
            services?: Input<Input<string>[]>;
            namespaces?: Input<Input<string>[]>;
        }
    }
}
export declare namespace security {
    namespace v1beta1 {
        interface AuthorizationPolicy {
            selector?: Input<WorkloadSelector>;
            rules?: Input<Input<Rule>[]>;
        }
        interface RuleArgs {
            metadata?: k8s.apiextensions.CustomResourceArgs['metadata'];
            spec: Input<Rule>;
        }
        interface Rule {
            from?: Input<Input<From>[]>;
            to?: Input<Input<To>[]>;
            when?: Input<Input<Condition>[]>;
        }
        interface From {
            source?: Input<Source>;
        }
        interface To {
            operation?: Input<Operation>;
        }
        interface Condition {
            values: Input<Input<string>[]>;
            key: Input<string>;
        }
        interface Source {
            principals?: Input<Input<string>[]>;
            requestPrincipals?: Input<Input<string>[]>;
            namespaces?: Input<Input<string>[]>;
            ipBlocks?: Input<Input<string>[]>;
        }
        interface Operation {
            hosts?: Input<Input<string>[]>;
            ports?: Input<Input<string>[]>;
            methods?: Input<Input<string>[]>;
            paths?: Input<Input<string>[]>;
        }
        interface WorkloadSelector {
            labels: Input<Record<Input<string>, Input<string>>>;
        }
    }
}
