export declare namespace authentication {
    namespace v1alpha1 {
        type StringMatch = {
            exact: string;
        } | {
            prefix: string;
        } | {
            suffix: string;
        } | {
            regex: string;
        };
        interface MutualTls {
            readonly allowTls: boolean;
            readonly mode: Mode;
        }
        type Mode = 'STRICT' | 'PERMISSIVE';
        interface Jwt {
            readonly issuer: string;
            readonly audiences: string[];
            readonly jwksUri: string;
            readonly jwks: string;
            readonly jwtHeaders: string[];
            readonly jwtParams: string[];
            readonly triggerRules: TriggerRule[];
        }
        interface TriggerRule {
            readonly excludedPaths: StringMatch[];
            readonly includedPaths: StringMatch[];
        }
        type PeerAuthenticationMethod = {
            mtls: MutualTls;
        } | {
            jwt: Jwt;
        };
        interface OriginAuthenticationMethod {
            readonly jwt: Jwt;
        }
        type PrincipalBinding = 'USE_PEER' | 'USE_ORIGIN';
        interface Policy {
            readonly targets: TargetSelector[];
            readonly peers: PeerAuthenticationMethod[];
            readonly peerIsOptional: boolean;
            readonly origins: OriginAuthenticationMethod[];
            readonly originIsOptional: boolean;
            readonly principalBinding: PrincipalBinding;
        }
        interface TargetSelector {
            readonly name: string;
            readonly labels: Record<string, string>;
            readonly ports: PortSelector[];
        }
        type PortSelector = {
            number: number;
        } | {
            name: string;
        };
    }
}
export declare namespace mcp {
    namespace v1alpha1 {
        interface SinkNode {
            readonly id: string;
            readonly annotations: Record<string, string>;
        }
        interface MeshConfigRequest {
            readonly typeUrl: string;
            readonly versionInfo: string;
            readonly sinkNode: SinkNode;
            readonly responseNonce: string;
            readonly errorDetail: Status;
        }
        interface MeshConfigResponse {
            readonly typeUrl: string;
            readonly versionInfo: string;
            readonly nonce: string;
        }
        interface IncrementalMeshConfigRequest {
            readonly typeUrl: string;
            readonly sinkNode: SinkNode;
            readonly responseNonce: string;
            readonly errorDetail: Status;
            readonly initialResourceVersions: Record<string, string>;
        }
        interface IncrementalMeshConfigResponse {
            readonly nonce: string;
            readonly systemVersionInfo: string;
            readonly removedResources: string[];
        }
        interface RequestResources {
            readonly sinkNode: SinkNode;
            readonly responseNonce: string;
            readonly errorDetail: Status;
            readonly initialResourceVersions: Record<string, string>;
            readonly collection: string;
            readonly incremental: boolean;
        }
        interface Resources {
            readonly nonce: string;
            readonly systemVersionInfo: string;
            readonly removedResources: string[];
            readonly collection: string;
            readonly incremental: boolean;
        }
        interface Metadata {
            readonly name: string;
            readonly annotations: Record<string, string>;
            readonly createTime: Timestamp;
            readonly version: string;
            readonly labels: Record<string, string>;
        }
        interface Resource {
            readonly body: Any;
            readonly metadata: Metadata;
        }
        interface Any {
            readonly typeUrl: string;
            readonly value: string;
        }
        interface Timestamp {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface Status {
            readonly code: number;
            readonly message: string;
            readonly details: Any[];
        }
    }
}
export declare namespace mesh {
    namespace v1alpha1 {
        interface MeshConfig {
            readonly connectTimeout: Duration;
            readonly tcpKeepalive: TcpKeepalive;
            readonly h2UpgradePolicy: H2UpgradePolicy;
            readonly outboundTrafficPolicy: OutboundTrafficPolicy;
            readonly mixerCheckServer: string;
            readonly mixerReportServer: string;
            readonly disablePolicyChecks: boolean;
            readonly policyCheckFailOpen: boolean;
            readonly sidecarToTelemetrySessionAffinity: boolean;
            readonly proxyListenPort: number;
            readonly proxyHttpPort: number;
            readonly protocolDetectionTimeout: Duration;
            readonly ingressClass: string;
            readonly ingressService: string;
            readonly ingressControllerMode: IngressControllerMode;
            readonly authPolicy: AuthPolicy;
            readonly rdsRefreshDelay: Duration;
            readonly enableTracing: boolean;
            readonly accessLogFile: string;
            readonly accessLogFormat: string;
            readonly accessLogEncoding: AccessLogEncoding;
            readonly enableEnvoyAccessLogService: boolean;
            readonly defaultConfig: ProxyConfig;
            readonly mixerAddress: string;
            readonly enableClientSidePolicyCheck: boolean;
            readonly sdsUdsPath: string;
            readonly sdsRefreshDelay: Duration;
            readonly configSources: ConfigSource[];
            readonly enableSdsTokenMount: boolean;
            readonly sdsUseK8sSaJwt: boolean;
            readonly trustDomain: string;
            readonly defaultServiceExportTo: string[];
            readonly defaultVirtualServiceExportTo: string[];
            readonly defaultDestinationRuleExportTo: string[];
            readonly rootNamespace: string;
            readonly localityLbSetting: LocalityLoadBalancerSetting;
            readonly dnsRefreshRate: Duration;
            readonly disableReportBatch: boolean;
            readonly reportBatchMaxEntries: number;
            readonly reportBatchMaxTime: Duration;
        }
        type IngressControllerMode = 'OFF' | 'DEFAULT' | 'STRICT';
        type AuthPolicy = 'NONE' | 'MUTUAL_TLS';
        type AccessLogEncoding = 'TEXT' | 'JSON';
        interface ProxyConfig {
            readonly connectTimeout: Duration;
            readonly configPath: string;
            readonly binaryPath: string;
            readonly serviceCluster: string;
            readonly drainDuration: Duration;
            readonly parentShutdownDuration: Duration;
            readonly discoveryAddress: string;
            readonly discoveryRefreshDelay: Duration;
            readonly zipkinAddress: string;
            readonly statsdUdpAddress: string;
            readonly envoyMetricsServiceAddress: string;
            readonly proxyAdminPort: number;
            readonly availabilityZone: string;
            readonly controlPlaneAuthPolicy: AuthenticationPolicy;
            readonly customConfigFile: string;
            readonly statNameLength: number;
            readonly concurrency: number;
            readonly proxyBootstrapTemplatePath: string;
            readonly interceptionMode: InboundInterceptionMode;
            readonly tracing: Tracing;
            readonly sds: SDS;
            readonly envoyAccessLogService: RemoteService;
            readonly envoyMetricsService: RemoteService;
        }
        interface OutboundTrafficPolicy {
            readonly mode: Mode;
        }
        interface ConfigSource {
            readonly address: string;
            readonly tlsSettings: TLSSettings;
        }
        interface LocalityLoadBalancerSetting {
            readonly distribute: Distribute[];
            readonly failover: Failover[];
        }
        type H2UpgradePolicy = 'DO_NOT_UPGRADE' | 'UPGRADE';
        type Mode = 'REGISTRY_ONLY' | 'ALLOW_ANY';
        interface Distribute {
            readonly from: string;
            readonly to: Record<string, number>;
        }
        interface Failover {
            readonly from: string;
            readonly to: string;
        }
        interface Network {
            readonly endpoints: NetworkEndpoints[];
            readonly gateways: IstioNetworkGateway[];
        }
        type NetworkEndpoints = {
            fromCidr: string;
        } | {
            fromRegistry: string;
        };
        type IstioNetworkGateway = {
            port: number;
        } | {
            locality: string;
        } | {
            registryServiceName: string;
        } | {
            port: number;
        } | {
            address: string;
        } | {
            locality: string;
        };
        interface MeshNetworks {
            readonly networks: Record<string, Network>;
        }
        type AuthenticationPolicy = 'NONE' | 'MUTUAL_TLS' | 'INHERIT';
        type Tracing = {
            zipkin: Zipkin;
        } | {
            lightstep: Lightstep;
        } | {
            datadog: Datadog;
        } | {
            stackdriver: Stackdriver;
        };
        interface Zipkin {
            readonly address: string;
        }
        interface Lightstep {
            readonly address: string;
            readonly accessToken: string;
            readonly secure: boolean;
            readonly cacertPath: string;
        }
        interface Datadog {
            readonly address: string;
        }
        interface Stackdriver {
            readonly debug: boolean;
            readonly maxNumberOfAttributes: Int64Value;
            readonly maxNumberOfAnnotations: Int64Value;
            readonly maxNumberOfMessageEvents: Int64Value;
        }
        interface SDS {
            readonly enabled: boolean;
            readonly k8sSaJwtPath: string;
        }
        type InboundInterceptionMode = 'REDIRECT' | 'TPROXY';
        interface RemoteService {
            readonly tcpKeepalive: TcpKeepalive;
            readonly address: string;
            readonly tlsSettings: TLSSettings;
        }
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface Int64Value {
            readonly value: number;
        }
        interface TcpKeepalive {
            readonly time: Duration;
            readonly probes: number;
            readonly interval: Duration;
        }
        interface TLSSettings {
            readonly mode: TLSmode;
            readonly clientCertificate: string;
            readonly privateKey: string;
            readonly caCertificates: string;
            readonly subjectAltNames: string[];
            readonly sni: string;
        }
        type TLSmode = 'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL';
    }
}
export declare namespace mixer {
    namespace v1 {
        interface Attributes {
            readonly attributes: Record<string, AttributeValue>;
        }
        type AttributeValue = {
            stringValue: string;
        } | {
            int64Value: number;
        } | {
            doubleValue: number;
        } | {
            boolValue: boolean;
        } | {
            bytesValue: string;
        } | {
            timestampValue: Timestamp;
        } | {
            durationValue: Duration;
        } | {
            stringMapValue: StringMap;
        };
        interface StringMap {
            readonly entries: Record<string, string>;
        }
        interface CompressedAttributes {
            readonly strings: Record<string, number>;
            readonly bytes: object;
            readonly words: string[];
            readonly int64s: Record<string, number>;
            readonly doubles: Record<string, number>;
            readonly bools: Record<string, boolean>;
            readonly timestamps: Record<string, Timestamp>;
            readonly durations: Record<string, Duration>;
            readonly stringMaps: Record<string, StringMap>;
        }
        interface StringMap {
            readonly entries: Record<string, number>;
        }
        interface CheckRequest {
            readonly globalWordCount: number;
            readonly deduplicationId: string;
            readonly quotas: Record<string, QuotaParams>;
        }
        interface QuotaParams {
            readonly amount: number;
            readonly bestEffort: boolean;
        }
        interface CheckResponse {
            readonly quotas: Record<string, QuotaResult>;
        }
        interface QuotaResult {
            readonly grantedAmount: number;
        }
        interface PreconditionResult {
            readonly validUseCount: number;
            readonly referencedAttributes: ReferencedAttributes;
            readonly routeDirective: RouteDirective;
        }
        interface ReferencedAttributes {
            readonly words: string[];
        }
        interface RouteDirective {
            readonly directResponseCode: number;
            readonly directResponseBody: string;
        }
        type Condition = 'CONDITION_UNSPECIFIED' | 'ABSENCE' | 'EXACT' | 'REGEX';
        interface AttributeMatch {
            readonly name: number;
            readonly condition: Condition;
            readonly regex: string;
            readonly mapKey: number;
        }
        interface HeaderOperation {
            readonly name: string;
            readonly value: string;
            readonly operation: Operation;
        }
        type Operation = 'REPLACE' | 'REMOVE' | 'APPEND';
        interface ReportRequest {
            readonly globalWordCount: number;
            readonly repeatedAttributesSemantics: RepeatedAttributesSemantics;
            readonly defaultWords: string[];
        }
        type RepeatedAttributesSemantics = 'DELTA_ENCODING' | 'INDEPENDENT_ENCODING';
        interface ReportResponse {
        }
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface Timestamp {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface HTTPAPISpec {
            readonly attributes: Attributes;
            readonly patterns: HTTPAPISpecPattern[];
            readonly apiKeys: APIKey[];
        }
        type HTTPAPISpecPattern = {
            attributes: Attributes;
        } | {
            httpMethod: string;
        } | {
            uriTemplate: string;
        } | {
            attributes: Attributes;
        } | {
            regex: string;
        } | {
            httpMethod: string;
        };
        type APIKey = {
            query: string;
        } | {
            header: string;
        } | {
            cookie: string;
        };
        interface HTTPAPISpecReference {
            readonly name: string;
            readonly namespace: string;
        }
        interface HTTPAPISpecBinding {
            readonly services: IstioService[];
            readonly apiSpecs: HTTPAPISpecReference[];
        }
        interface IstioService {
            readonly name: string;
            readonly namespace: string;
            readonly domain: string;
            readonly service: string;
            readonly labels: Record<string, string>;
        }
        interface NetworkFailPolicy {
            readonly policy: FailPolicy;
            readonly maxRetry: number;
            readonly baseRetryWait: Duration;
            readonly maxRetryWait: Duration;
        }
        type FailPolicy = 'FAIL_OPEN' | 'FAIL_CLOSE';
        interface ServiceConfig {
            readonly disableCheckCalls: boolean;
            readonly disableReportCalls: boolean;
            readonly mixerAttributes: Attributes;
            readonly httpApiSpec: HTTPAPISpec[];
            readonly quotaSpec: QuotaSpec[];
            readonly networkFailPolicy: NetworkFailPolicy;
            readonly forwardAttributes: Attributes;
        }
        interface QuotaSpec {
            readonly rules: QuotaRule[];
        }
        interface TransportConfig {
            readonly networkFailPolicy: NetworkFailPolicy;
            readonly disableCheckCache: boolean;
            readonly disableQuotaCache: boolean;
            readonly disableReportBatch: boolean;
            readonly statsUpdateInterval: Duration;
            readonly checkCluster: string;
            readonly reportCluster: string;
            readonly attributesForMixerProxy: Attributes;
            readonly reportBatchMaxEntries: number;
            readonly reportBatchMaxTime: Duration;
        }
        interface HttpClientConfig {
            readonly mixerAttributes: Attributes;
            readonly forwardAttributes: Attributes;
            readonly transport: TransportConfig;
            readonly serviceConfigs: Record<string, ServiceConfig>;
            readonly defaultDestinationService: string;
        }
        interface TcpClientConfig {
            readonly disableCheckCalls: boolean;
            readonly disableReportCalls: boolean;
            readonly mixerAttributes: Attributes;
            readonly transport: TransportConfig;
            readonly connectionQuotaSpec: QuotaSpec;
            readonly reportInterval: Duration;
        }
        interface QuotaRule {
            readonly quotas: Quota[];
            readonly match: AttributeMatch[];
        }
        interface AttributeMatch {
            readonly clause: Record<string, StringMatch>;
        }
        interface Quota {
            readonly quota: string;
            readonly charge: number;
        }
        type StringMatch = {
            exact: string;
        } | {
            prefix: string;
        } | {
            regex: string;
        };
        interface QuotaSpecBinding {
            readonly services: IstioService[];
            readonly quotaSpecs: QuotaSpecReference[];
        }
        interface QuotaSpecReference {
            readonly name: string;
            readonly namespace: string;
        }
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface Attributes {
            readonly attributes: Record<string, AttributeValue>;
        }
        type AttributeValue = {
            stringValue: string;
        } | {
            int64Value: number;
        } | {
            doubleValue: number;
        } | {
            boolValue: boolean;
        } | {
            bytesValue: string;
        } | {
            timestampValue: Timestamp;
        } | {
            durationValue: Duration;
        } | {
            stringMapValue: StringMap;
        };
        interface Timestamp {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface StringMap {
            readonly entries: Record<string, string>;
        }
    }
}
export declare namespace networking {
    namespace v1alpha3 {
        interface DestinationRule {
            readonly host: string;
            readonly trafficPolicy: TrafficPolicy;
            readonly subsets: Subset[];
            readonly exportTo: string[];
        }
        interface TrafficPolicy {
            readonly loadBalancer: LoadBalancerSettings;
            readonly connectionPool: ConnectionPoolSettings;
            readonly outlierDetection: OutlierDetection;
            readonly tls: TLSSettings;
            readonly portLevelSettings: PortTrafficPolicy[];
        }
        interface Subset {
            readonly name: string;
            readonly trafficPolicy: TrafficPolicy;
            readonly labels: Record<string, string>;
        }
        type LoadBalancerSettings = {
            simple: SimpleLB;
        } | {
            consistentHash: ConsistentHashLB;
        };
        interface ConnectionPoolSettings {
            readonly tcp: TCPSettings;
            readonly http: HTTPSettings;
        }
        interface OutlierDetection {
            readonly interval: Duration;
            readonly consecutiveErrors: number;
            readonly baseEjectionTime: Duration;
            readonly maxEjectionPercent: number;
            readonly minHealthPercent: number;
        }
        interface TLSSettings {
            readonly mode: TLSmode;
            readonly clientCertificate: string;
            readonly privateKey: string;
            readonly caCertificates: string;
            readonly subjectAltNames: string[];
            readonly sni: string;
        }
        interface PortTrafficPolicy {
            readonly loadBalancer: LoadBalancerSettings;
            readonly connectionPool: ConnectionPoolSettings;
            readonly outlierDetection: OutlierDetection;
            readonly tls: TLSSettings;
            readonly port: PortSelector;
        }
        type PortSelector = {
            number: number;
        } | {
            name: string;
        };
        type SimpleLB = 'ROUND_ROBIN' | 'LEAST_CONN' | 'RANDOM' | 'PASSTHROUGH';
        type ConsistentHashLB = {
            minimumRingSize: number;
        } | {
            httpHeaderName: string;
        } | {
            minimumRingSize: number;
        } | {
            httpCookie: HTTPCookie;
        } | {
            minimumRingSize: number;
        } | {
            useSourceIp: boolean;
        };
        interface HTTPCookie {
            readonly path: string;
            readonly name: string;
        }
        interface TCPSettings {
            readonly maxConnections: number;
            readonly connectTimeout: Duration;
            readonly tcpKeepalive: TcpKeepalive;
        }
        interface HTTPSettings {
            readonly http1MaxPendingRequests: number;
            readonly http2MaxRequests: number;
            readonly maxRequestsPerConnection: number;
            readonly maxRetries: number;
            readonly idleTimeout: Duration;
            readonly h2UpgradePolicy: H2UpgradePolicy;
        }
        interface TcpKeepalive {
            readonly time: Duration;
            readonly probes: number;
            readonly interval: Duration;
        }
        type H2UpgradePolicy = 'DEFAULT' | 'DO_NOT_UPGRADE' | 'UPGRADE';
        type TLSmode = 'DISABLE' | 'SIMPLE' | 'MUTUAL' | 'ISTIO_MUTUAL';
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface EnvoyFilter {
            readonly workloadLabels: Record<string, string>;
            readonly filters: Filter[];
            readonly workloadSelector: WorkloadSelector;
            readonly configPatches: EnvoyConfigObjectPatch[];
        }
        interface Filter {
            readonly listenerMatch: DeprecatedListenerMatch;
            readonly insertPosition: InsertPosition;
            readonly filterType: FilterType;
            readonly filterName: string;
            readonly filterConfig: Struct;
        }
        interface WorkloadSelector {
            readonly labels: Record<string, string>;
        }
        interface EnvoyConfigObjectPatch {
            readonly applyTo: ApplyTo;
            readonly match: EnvoyConfigObjectMatch;
            readonly patch: Patch;
        }
        interface DeprecatedListenerMatch {
            readonly portNumber: number;
            readonly portNamePrefix: string;
            readonly listenerType: ListenerType;
            readonly listenerProtocol: ListenerProtocol;
            readonly address: string[];
        }
        type ListenerType = 'ANY' | 'SIDECAR_INBOUND' | 'SIDECAR_OUTBOUND' | 'GATEWAY';
        type ListenerProtocol = 'ALL' | 'HTTP' | 'TCP';
        interface InsertPosition {
            readonly index: Index;
            readonly relativeTo: string;
        }
        type Index = 'FIRST' | 'LAST' | 'BEFORE' | 'AFTER';
        type FilterType = 'INVALID' | 'HTTP' | 'NETWORK';
        type ApplyTo = 'INVALID' | 'LISTENER' | 'FILTER_CHAIN' | 'NETWORK_FILTER' | 'HTTP_FILTER' | 'ROUTE_CONFIGURATION' | 'VIRTUAL_HOST' | 'HTTP_ROUTE' | 'CLUSTER';
        type PatchContext = 'ANY' | 'SIDECAR_INBOUND' | 'SIDECAR_OUTBOUND' | 'GATEWAY';
        interface ProxyMatch {
            readonly proxyVersion: string;
            readonly metadata: Record<string, string>;
        }
        interface ClusterMatch {
            readonly name: string;
            readonly portNumber: number;
            readonly service: string;
            readonly subset: string;
        }
        interface RouteConfigurationMatch {
            readonly name: string;
            readonly portNumber: number;
            readonly portName: string;
            readonly gateway: string;
            readonly vhost: VirtualHostMatch;
        }
        interface VirtualHostMatch {
            readonly name: string;
            readonly route: RouteMatch;
        }
        interface RouteMatch {
            readonly name: string;
            readonly action: Action;
        }
        type Action = 'ANY' | 'ROUTE' | 'REDIRECT' | 'DIRECT_RESPONSE';
        interface ListenerMatch {
            readonly name: string;
            readonly portNumber: number;
            readonly portName: string;
            readonly filterChain: FilterChainMatch;
        }
        interface FilterChainMatch {
            readonly name: string;
            readonly sni: string;
            readonly transportProtocol: string;
            readonly applicationProtocols: string;
            readonly filter: FilterMatch;
        }
        interface FilterMatch {
            readonly name: string;
            readonly subFilter: SubFilterMatch;
        }
        interface SubFilterMatch {
            readonly name: string;
        }
        interface Patch {
            readonly operation: Operation;
            readonly value: Struct;
        }
        type Operation = 'INVALID' | 'MERGE' | 'ADD' | 'REMOVE' | 'INSERT_BEFORE' | 'INSERT_AFTER';
        type EnvoyConfigObjectMatch = {
            context: PatchContext;
        } | {
            proxy: ProxyMatch;
        } | {
            listener: ListenerMatch;
        } | {
            context: PatchContext;
        } | {
            proxy: ProxyMatch;
        } | {
            routeConfiguration: RouteConfigurationMatch;
        } | {
            context: PatchContext;
        } | {
            proxy: ProxyMatch;
        } | {
            cluster: ClusterMatch;
        };
        interface Struct {
            readonly fields: Record<string, Value>;
        }
        type Value = {
            nullValue: NullValue;
        } | {
            numberValue: number;
        } | {
            stringValue: string;
        } | {
            boolValue: boolean;
        } | {
            structValue: Struct;
        } | {
            listValue: ListValue;
        };
        interface ListValue {
            readonly values: Value[];
        }
        type NullValue = 'NULL_VALUE';
        interface Gateway {
            readonly servers: Server[];
            readonly selector: Record<string, string>;
        }
        interface Server {
            readonly tls: TLSOptions;
            readonly port: Port;
            readonly bind: string;
            readonly hosts: string[];
            readonly defaultEndpoint: string;
        }
        interface Port {
            readonly name: string;
            readonly number: number;
            readonly protocol: string;
        }
        interface TLSOptions {
            readonly mode: TLSmode;
            readonly privateKey: string;
            readonly caCertificates: string;
            readonly subjectAltNames: string[];
            readonly httpsRedirect: boolean;
            readonly serverCertificate: string;
            readonly credentialName: string;
            readonly verifyCertificateSpki: string[];
            readonly verifyCertificateHash: string[];
            readonly minProtocolVersion: TLSProtocol;
            readonly maxProtocolVersion: TLSProtocol;
            readonly cipherSuites: string[];
        }
        type TLSmode = 'PASSTHROUGH' | 'SIMPLE' | 'MUTUAL' | 'AUTO_PASSTHROUGH' | 'ISTIO_MUTUAL';
        type TLSProtocol = 'TLS_AUTO' | 'TLSV1_0' | 'TLSV1_1' | 'TLSV1_2' | 'TLSV1_3';
        interface Port {
            readonly name: string;
            readonly number: number;
            readonly protocol: string;
        }
        interface ServiceEntry {
            readonly exportTo: string[];
            readonly subjectAltNames: string[];
            readonly hosts: string[];
            readonly addresses: string[];
            readonly ports: Port[];
            readonly location: Location;
            readonly resolution: Resolution;
            readonly endpoints: Endpoint[];
        }
        type Location = 'MESH_EXTERNAL' | 'MESH_INTERNAL';
        type Resolution = 'NONE' | 'STATIC' | 'DNS';
        interface Endpoint {
            readonly labels: Record<string, string>;
            readonly address: string;
            readonly ports: Record<string, number>;
            readonly network: string;
            readonly locality: string;
            readonly weight: number;
        }
        interface WorkloadSelector {
            readonly labels: Record<string, string>;
        }
        interface Port {
            readonly name: string;
            readonly number: number;
            readonly protocol: string;
        }
        interface Sidecar {
            readonly workloadSelector: WorkloadSelector;
            readonly ingress: IstioIngressListener[];
            readonly egress: IstioEgressListener[];
            readonly outboundTrafficPolicy: OutboundTrafficPolicy;
        }
        interface IstioIngressListener {
            readonly port: Port;
            readonly bind: string;
            readonly defaultEndpoint: string;
            readonly captureMode: CaptureMode;
        }
        interface IstioEgressListener {
            readonly port: Port;
            readonly bind: string;
            readonly hosts: string[];
            readonly captureMode: CaptureMode;
        }
        interface OutboundTrafficPolicy {
            readonly mode: Mode;
        }
        type CaptureMode = 'DEFAULT' | 'IPTABLES' | 'NONE';
        type Mode = 'REGISTRY_ONLY' | 'ALLOW_ANY';
        type PortSelector = {
            number: number;
        } | {
            name: string;
        };
        interface VirtualService {
            readonly exportTo: string[];
            readonly tls: TLSRoute[];
            readonly tcp: TCPRoute[];
            readonly http: HTTPRoute[];
            readonly hosts: string[];
            readonly gateways: string[];
        }
        interface HTTPRoute {
            readonly name: string;
            readonly route: HTTPRouteDestination[];
            readonly match: HTTPMatchRequest[];
            readonly redirect: HTTPRedirect;
            readonly rewrite: HTTPRewrite;
            readonly websocketUpgrade: boolean;
            readonly timeout: Duration;
            readonly retries: HTTPRetry;
            readonly fault: HTTPFaultInjection;
            readonly mirror: Destination;
            readonly corsPolicy: CorsPolicy;
            readonly appendHeaders: Record<string, string>;
            readonly removeResponseHeaders: string[];
            readonly appendResponseHeaders: Record<string, string>;
            readonly removeRequestHeaders: string[];
            readonly appendRequestHeaders: Record<string, string>;
            readonly headers: Headers;
        }
        interface TLSRoute {
            readonly route: RouteDestination[];
            readonly match: TLSMatchAttributes[];
        }
        interface TCPRoute {
            readonly route: RouteDestination[];
            readonly match: L4MatchAttributes[];
        }
        interface Destination {
            readonly host: string;
            readonly port: PortSelector;
            readonly subset: string;
        }
        interface HTTPMatchRequest {
            readonly name: string;
            readonly method: StringMatch;
            readonly port: number;
            readonly gateways: string[];
            readonly headers: Record<string, StringMatch>;
            readonly uri: StringMatch;
            readonly scheme: StringMatch;
            readonly authority: StringMatch;
            readonly sourceLabels: Record<string, string>;
            readonly queryParams: Record<string, StringMatch>;
            readonly ignoreUriCase: boolean;
        }
        interface HTTPRouteDestination {
            readonly weight: number;
            readonly removeResponseHeaders: string[];
            readonly appendResponseHeaders: Record<string, string>;
            readonly removeRequestHeaders: string[];
            readonly appendRequestHeaders: Record<string, string>;
            readonly headers: Headers;
            readonly destination: Destination;
        }
        interface HTTPRedirect {
            readonly uri: string;
            readonly authority: string;
            readonly redirectCode: number;
        }
        interface HTTPRewrite {
            readonly uri: string;
            readonly authority: string;
        }
        interface HTTPRetry {
            readonly attempts: number;
            readonly perTryTimeout: Duration;
            readonly retryOn: string;
        }
        interface HTTPFaultInjection {
            readonly delay: Delay;
            readonly abort: Abort;
        }
        interface CorsPolicy {
            readonly allowOrigin: string[];
            readonly allowMethods: string[];
            readonly allowHeaders: string[];
            readonly exposeHeaders: string[];
            readonly maxAge: Duration;
            readonly allowCredentials: BoolValue;
        }
        interface Headers {
            readonly response: HeaderOperations;
            readonly request: HeaderOperations;
        }
        interface HeaderOperations {
            readonly set: Record<string, string>;
            readonly add: Record<string, string>;
            readonly remove: string[];
        }
        interface TLSMatchAttributes {
            readonly port: number;
            readonly gateways: string[];
            readonly sourceLabels: Record<string, string>;
            readonly destinationSubnets: string[];
            readonly sourceSubnet: string;
            readonly sniHosts: string[];
        }
        interface RouteDestination {
            readonly weight: number;
            readonly destination: Destination;
        }
        interface L4MatchAttributes {
            readonly port: number;
            readonly gateways: string[];
            readonly sourceLabels: Record<string, string>;
            readonly destinationSubnets: string[];
            readonly sourceSubnet: string;
        }
        type StringMatch = {
            exact: string;
        } | {
            prefix: string;
        } | {
            regex: string;
        };
        type Delay = {
            percent: number;
        } | {
            percentage: Percent;
        } | {
            fixedDelay: Duration;
        } | {
            percent: number;
        } | {
            percentage: Percent;
        } | {
            exponentialDelay: Duration;
        };
        type Abort = {
            percent: number;
        } | {
            percentage: Percent;
        } | {
            httpStatus: number;
        } | {
            percent: number;
        } | {
            percentage: Percent;
        } | {
            grpcStatus: string;
        } | {
            percent: number;
        } | {
            percentage: Percent;
        } | {
            http2Error: string;
        };
        interface Percent {
            readonly value: number;
        }
        interface BoolValue {
            readonly value: boolean;
        }
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
    }
}
export declare namespace policy {
    namespace v1beta1 {
        interface Duration {
            readonly value: Duration;
        }
        type Value = {
            stringValue: string;
        } | {
            int64Value: number;
        } | {
            doubleValue: number;
        } | {
            boolValue: boolean;
        } | {
            ipAddressValue: IPAddress;
        } | {
            timestampValue: TimeStamp;
        } | {
            durationValue: Duration;
        } | {
            emailAddressValue: EmailAddress;
        } | {
            dnsNameValue: DNSName;
        } | {
            uriValue: Uri;
        } | {
            stringMapValue: StringMap;
        };
        interface AttributeManifest {
            readonly name: string;
            readonly revision: string;
            readonly attributes: Record<string, AttributeInfo>;
        }
        interface AttributeInfo {
            readonly description: string;
            readonly valueType: ValueType;
        }
        type ValueType = 'VALUE_TYPE_UNSPECIFIED' | 'STRING' | 'INT64' | 'DOUBLE' | 'BOOL' | 'TIMESTAMP' | 'IP_ADDRESS' | 'EMAIL_ADDRESS' | 'URI' | 'DNS_NAME' | 'DURATION' | 'STRING_MAP';
        interface Rule {
            readonly match: string;
            readonly actions: Action[];
            readonly requestHeaderOperations: HeaderOperationTemplate[];
            readonly responseHeaderOperations: HeaderOperationTemplate[];
            readonly sampling: Sampling;
        }
        interface Action {
            readonly name: string;
            readonly handler: string;
            readonly instances: string[];
        }
        interface HeaderOperationTemplate {
            readonly name: string;
            readonly values: string[];
            readonly operation: Operation;
        }
        interface Sampling {
            readonly random: RandomSampling;
            readonly rateLimit: RateLimitSampling;
        }
        type Operation = 'REPLACE' | 'REMOVE' | 'APPEND';
        interface Instance {
            readonly name: string;
            readonly compiledTemplate: string;
            readonly template: string;
            readonly params: Struct;
            readonly attributeBindings: Record<string, string>;
        }
        interface Handler {
            readonly name: string;
            readonly params: Struct;
            readonly compiledAdapter: string;
            readonly adapter: string;
            readonly connection: Connection;
        }
        interface Connection {
            readonly address: string;
            readonly authentication: Authentication;
        }
        type Authentication = {
            tls: Tls;
        } | {
            mutual: Mutual;
        };
        interface RandomSampling {
            readonly attributeExpression: string;
            readonly percentSampled: FractionalPercent;
            readonly useIndependentRandomness: boolean;
        }
        interface RateLimitSampling {
            readonly maxUnsampledEntries: number;
            readonly samplingRate: number;
        }
        interface FractionalPercent {
            readonly numerator: number;
            readonly denominator: DenominatorType;
        }
        type DenominatorType = 'HUNDRED' | 'TEN_THOUSAND';
        type Tls = {
            caCertificates: string;
        } | {
            serverName: string;
        } | {
            tokenPath: string;
        } | {
            authHeader: AuthHeader;
        } | {
            caCertificates: string;
        } | {
            serverName: string;
        } | {
            tokenPath: string;
        } | {
            customHeader: string;
        } | {
            caCertificates: string;
        } | {
            serverName: string;
        } | {
            oauth: OAuth;
        } | {
            authHeader: AuthHeader;
        } | {
            caCertificates: string;
        } | {
            serverName: string;
        } | {
            oauth: OAuth;
        } | {
            customHeader: string;
        };
        interface Mutual {
            readonly caCertificates: string;
            readonly serverName: string;
            readonly privateKey: string;
            readonly clientCertificate: string;
        }
        interface OAuth {
            readonly clientId: string;
            readonly clientSecret: string;
            readonly tokenUrl: string;
            readonly scopes: string[];
            readonly endpointParams: Record<string, string>;
        }
        type AuthHeader = 'PLAIN' | 'BEARER';
        interface DirectHttpResponse {
            readonly body: string;
            readonly code: HttpStatusCode;
            readonly headers: Record<string, string>;
        }
        type HttpStatusCode = 'Empty' | 'Continue' | 'OK' | 'Created' | 'Accepted' | 'NonAuthoritativeInformation' | 'NoContent' | 'ResetContent' | 'PartialContent' | 'MultiStatus' | 'AlreadyReported' | 'IMUsed' | 'MultipleChoices' | 'MovedPermanently' | 'Found' | 'SeeOther' | 'NotModified' | 'UseProxy' | 'TemporaryRedirect' | 'PermanentRedirect' | 'BadRequest' | 'Unauthorized' | 'PaymentRequired' | 'Forbidden' | 'NotFound' | 'MethodNotAllowed' | 'NotAcceptable' | 'ProxyAuthenticationRequired' | 'RequestTimeout' | 'Conflict' | 'Gone' | 'LengthRequired' | 'PreconditionFailed' | 'PayloadTooLarge' | 'URITooLong' | 'UnsupportedMediaType' | 'RangeNotSatisfiable' | 'ExpectationFailed' | 'MisdirectedRequest' | 'UnprocessableEntity' | 'Locked' | 'FailedDependency' | 'UpgradeRequired' | 'PreconditionRequired' | 'TooManyRequests' | 'RequestHeaderFieldsTooLarge' | 'InternalServerError' | 'NotImplemented' | 'BadGateway' | 'ServiceUnavailable' | 'GatewayTimeout' | 'HTTPVersionNotSupported' | 'VariantAlsoNegotiates' | 'InsufficientStorage' | 'LoopDetected' | 'NotExtended' | 'NetworkAuthenticationRequired';
        interface IPAddress {
            readonly value: string;
        }
        interface TimeStamp {
            readonly value: Timestamp;
        }
        interface EmailAddress {
            readonly value: string;
        }
        interface DNSName {
            readonly value: string;
        }
        interface Uri {
            readonly value: string;
        }
        interface StringMap {
            readonly value: Record<string, string>;
        }
        interface Duration {
            readonly seconds: number;
            readonly nanos: number;
        }
        interface Struct {
            readonly fields: Record<string, Value>;
        }
        interface Timestamp {
            readonly seconds: number;
            readonly nanos: number;
        }
        type Value = {
            nullValue: NullValue;
        } | {
            numberValue: number;
        } | {
            stringValue: string;
        } | {
            boolValue: boolean;
        } | {
            structValue: Struct;
        } | {
            listValue: ListValue;
        };
        interface ListValue {
            readonly values: Value[];
        }
        type NullValue = 'NULL_VALUE';
    }
}
export declare namespace rbac {
    namespace v1alpha1 {
        interface ServiceRole {
            readonly rules: AccessRule[];
        }
        interface AccessRule {
            readonly services: string[];
            readonly hosts: string[];
            readonly notHosts: string[];
            readonly paths: string[];
            readonly notPaths: string[];
            readonly methods: string[];
            readonly notMethods: string[];
            readonly ports: number[];
            readonly notPorts: number[];
            readonly constraints: Constraint[];
        }
        interface Constraint {
            readonly key: string;
            readonly values: string[];
        }
        type EnforcementMode = 'ENFORCED' | 'PERMISSIVE';
        interface ServiceRoleBinding {
            readonly subjects: Subject[];
            readonly roleRef: RoleRef;
            readonly mode: EnforcementMode;
            readonly actions: AccessRule[];
            readonly role: string;
        }
        interface Subject {
            readonly user: string;
            readonly names: string[];
            readonly notNames: string[];
            readonly group: string;
            readonly groups: string[];
            readonly notGroups: string[];
            readonly namespaces: string[];
            readonly notNamespaces: string[];
            readonly ips: string[];
            readonly notIps: string[];
            readonly properties: Record<string, string>;
        }
        interface RoleRef {
            readonly name: string;
            readonly kind: string;
        }
        interface RbacConfig {
            readonly mode: Mode;
            readonly inclusion: Target;
            readonly exclusion: Target;
            readonly enforcementMode: EnforcementMode;
        }
        type Mode = 'OFF' | 'ON' | 'ON_WITH_INCLUSION' | 'ON_WITH_EXCLUSION';
        interface Target {
            readonly services: string[];
            readonly namespaces: string[];
        }
    }
}
export declare namespace security {
    namespace v1beta1 {
        interface AuthorizationPolicy {
            readonly selector: WorkloadSelector;
            readonly rules: Rule[];
        }
        interface Rule {
            readonly from: From[];
            readonly to: To[];
            readonly when: Condition[];
        }
        interface From {
            readonly source: Source;
        }
        interface To {
            readonly operation: Operation;
        }
        interface Condition {
            readonly values: string[];
            readonly key: string;
        }
        interface Source {
            readonly principals: string[];
            readonly requestPrincipals: string[];
            readonly namespaces: string[];
            readonly ipBlocks: string[];
        }
        interface Operation {
            readonly hosts: string[];
            readonly ports: string[];
            readonly methods: string[];
            readonly paths: string[];
        }
        interface WorkloadSelector {
            readonly labels: Record<string, string>;
        }
    }
}
